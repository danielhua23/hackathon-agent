[{"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The provided Triton operator code implements a matrix-vector multiplication kernel, `mv_kernel`, designed for efficient execution on NVIDIA GPUs. It leverages Triton's Just-In-Time (JIT) compilation and auto-tuning features. The kernel function multiplies a matrix `A` of size N x M with a vector `B` of size M, resulting in an output vector `C` of size N. The kernel is parameterized by constants `BLOCK_N` and `BLOCK_M` which determine the tile sizes for the computation, allowing for optimal parallel processing. Within `mv_kernel`, a loop iterates over the matrix A in blocks of `BLOCK_M` to load sub-matrices and the corresponding block from vector B, performing element-wise multiplication and accumulation in shared memory. The partial results are then reduced along the rows and stored in the output vector `C`. The `mv` function wraps this kernel execution, asserting dimension compatibility and managing CUDA resources for launching the kernel with calculated grid dimensions.\n            ", "label": null, "file": "matrix_vector_multip.py", "test_code": "\n\n\ndef test_mv():\n    # \u6d4b\u8bd5\u7528\u4f8b 2: 4x3 \u77e9\u9635\u4e0e 3x1 \u5411\u91cf\u76f8\u4e58\n    A = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0], [10.0, 11.0, 12.0]], device='cuda')\n    B = torch.tensor([1.0, 2.0, 3.0], device='cuda')\n    triton_result_2 = mv(A, B)\n\n    # \u6d4b\u8bd5\u7528\u4f8b 3: 32x16 \u77e9\u9635\u4e0e 16x1 \u5411\u91cf\u76f8\u4e58\n    A = torch.randn(32, 16, device='cuda')\n    B = torch.randn(16, device='cuda')\n    triton_result_3 = mv(A, B)\n\n    return {\n        \"test_case_2\": triton_result_2,\n        \"test_case_3\": triton_result_3,\n    }\n\nresult_gold = test_mv()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef mv_kernel(A, B, C, M, N,\n              stride_am: tl.constexpr,\n              BLOCK_M: tl.constexpr,\n              BLOCK_N: tl.constexpr):\n    pid_m = tl.program_id(0)\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = tl.arange(0, BLOCK_N)\n\n    mask_m = offs_m < N\n    acc = tl.full((BLOCK_M,), 0.0, dtype=tl.float32)\n\n    for n_start in range(0, M, BLOCK_N):\n        offs_n_block = n_start + offs_n\n        mask_n = offs_n_block < M\n\n        a_offs = offs_m[:, None] * stride_am + offs_n_block[None, :]\n        a = tl.load(A + a_offs, mask=mask_m[:, None] & mask_n[None, :], other=0.0)\n        b = tl.load(B + offs_n_block, mask=mask_n, other=0.0)\n\n        acc += tl.sum(a * b[None, :], axis=1)\n\n    tl.store(C + offs_m, acc.to(C.dtype.element_ty), mask=mask_m)\n\ndef mv(A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n    assert A.dim() == 2, \"Matrix A should be 2D (NxM)\"\n    assert B.dim() == 1, \"Vector B should be 1D (M)\"\n    N, M = A.shape\n    assert B.size(0) == M, f\"Cannot multiply A ({N}x{M}) and B ({B.size(0)}), inner dimensions must match\"\n\n    C = torch.empty((N,), device=A.device, dtype=A.dtype)\n\n    def grid(meta):\n        return (triton.cdiv(N, meta['BLOCK_M']),)\n\n    mv_kernel[grid](\n        A, B, C, M, N,\n        stride_am=A.stride(0),\n        BLOCK_M=64,\n        BLOCK_N=64\n    )\n    return C\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n        The provided Triton kernel, `matmul_kernel`, is a specialized GPU matrix multiplication operation. \n        It employs a blocked tiling strategy for efficient computation of the result matrix `c` from input matrices `a` and `b`. \n        Within this kernel, operations are parallelized across blocks defined by BLOCK_SIZE_M, BLOCK_SIZE_N, and BLOCK_SIZE_K. \n        These blocks allow the kernel to load sub-matrices, perform computations, and manage memory more efficiently.\n\n        The kernel begins by computing indices for thread execution, segmenting the operation across various program IDs derived from the grid dimensions. \n        For each thread block, it computes offsets `offs_am`, `offs_bn`, and `offs_k` to read data from the input matrices.\n\n        In a loop iterating over slices of the K dimension, sub-matrices are loaded using `tl.load` with masks to handle boundary conditions. \n        These matrices are then multiplied using `tl.dot`, accumulating results in a local accumulator. \n        Memory access patterns are optimized using `tl.max_contiguous` and `tl.multiple_of` to align data in cache-friendly ways.\n\n        The function finally writes the accumulated results to the output matrix `c`, with care taken to respect bounds and using conditional storage via `tl.store`.\n\n        The `matmul` function wraps this kernel, preparing inputs and meta-parameters based on the matrix data types and dimensions. \n        It enforces input compatibility, establishes execution grid dimensions, and sets device memory for output. \n        Configuration parameters such as BLOCK_SIZE_M, num_stages, and num_warps are determined per data type, \n        ensuring optimal kernel execution tailored for either float16 or Triton's experimental float8 types.\n    ", "label": null, "file": "triton_matmul.py", "test_code": "\n\n\nimport torch\n\n# Test for matmul\ndef test_matmul():\n    results = {}\n    M, K, N = 256, 128, 256\n\n    # Test case 1: torch.float16\n    a = torch.randn((M, K), dtype=torch.float16, device='cuda')\n    b = torch.randn((K, N), dtype=torch.float16, device='cuda')\n    c = matmul(a, b)\n    results['test_case_1'] = c\n\n    return results\n\n# Run all tests\nresult_gold = test_matmul()", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_am = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n\n    offs_am = tl.max_contiguous(tl.multiple_of(offs_am % M, BLOCK_SIZE_M), BLOCK_SIZE_M)\n    offs_bn = tl.max_contiguous(tl.multiple_of(offs_bn % N, BLOCK_SIZE_N), BLOCK_SIZE_N)\n    offs_k = tl.max_contiguous(tl.multiple_of(offs_k, BLOCK_SIZE_K), BLOCK_SIZE_K)\n\n    a_ptrs = a_ptr + (offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn)\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_offset = k * BLOCK_SIZE_K\n        a_mask = (offs_k[None, :] + k_offset < K)\n        b_mask = (offs_k[:, None] + k_offset < K)\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_cm = tl.max_contiguous(tl.multiple_of(offs_cm % M, BLOCK_SIZE_M), BLOCK_SIZE_M)\n    offs_cn = tl.max_contiguous(tl.multiple_of(offs_cn % N, BLOCK_SIZE_N), BLOCK_SIZE_N)\n\n    c = accumulator.to(tl.float16)\n    ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(ptrs, c, mask=mask)\n\ndef matmul(a: torch.Tensor, b: torch.Tensor) -> torch.Tensor:\n    assert a.dim() == 2 and b.dim() == 2, \"Both tensors must be 2D\"\n    M, K = a.shape\n    K_b, N = b.shape\n    assert K == K_b, \"Inner dimensions must match\"\n    assert a.is_contiguous(), \"A must be contiguous\"\n    assert b.is_contiguous(), \"B must be contiguous\"\n\n    c = torch.empty((M, N), device=a.device, dtype=a.dtype)\n\n    def grid(META):\n        return (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n\n    matmul_kernel[grid](\n        a, b, c,\n        M, N, K,\n        a.stride(0), a.stride(1),\n        b.stride(0), b.stride(1),\n        c.stride(0), c.stride(1),\n        BLOCK_SIZE_M=128,\n        BLOCK_SIZE_N=128,\n        BLOCK_SIZE_K=32,\n        GROUP_SIZE_M=8,\n    )\n    return c\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The Triton-accelerated function embedding_kernel is specialized for extracting and storing embedding vectors from a weight matrix for a sequence of token IDs. It uses program IDs to determine processing offsets and handles iteration over sequences with BLOCK_N and BLOCK_NN stride sizes. For each sequence, it computes token IDs and uses masks to ensure only valid data is loaded and processed. The weight matrix is addressed using a combination of token IDs and dimension offsets, facilitated by the stride of the weight tensor. The processed vectors are then stored into the 'out' tensor using calculated strides and masks, ensuring each output sequence position receives the correct embedding vector. The wrapping function, embedding, configures and invokes the kernel with appropriate grid settings, aligning BLOCK_DMODEL to the next power of two based on weight dimensions and leveraging constant memory settings to optimize the embedding extraction process.\n            ", "label": null, "file": "embedding_triton_kernel.py", "test_code": "\n\n\nimport torch\n\ndef test_embedding():\n    # \u53c2\u6570\u5b9a\u4e49\n    vocab_size = 1000         # \u8bcd\u6c47\u8868\u5927\u5c0f\n    embedding_dim = 512       # \u5d4c\u5165\u7ef4\u5ea6\n    sequence_length = 128     # \u8f93\u5165\u5e8f\u5217\u957f\u5ea6\n    vob_start_id = 10         # \u8bcd\u6c47\u8868\u8d77\u59cb ID\n    vob_end_id = 1000         # \u8bcd\u6c47\u8868\u7ed3\u675f ID\n\n    # \u521b\u5efa\u6d4b\u8bd5\u8f93\u5165\u5f20\u91cf\n    input_ids = torch.randint(\n        vob_start_id, vob_end_id, (sequence_length,), dtype=torch.int32, device='cuda'\n    )\n    weight = torch.randn(\n        vocab_size, embedding_dim, dtype=torch.float32, device='cuda'\n    )\n    out = torch.zeros(\n        sequence_length, embedding_dim, dtype=torch.float32, device='cuda'\n    )\n\n    # \u8c03\u7528\u5d4c\u5165\u51fd\u6570\n    embedding(input_ids, weight, vob_start_id, vob_end_id, out)\n\n    # \u4fdd\u5b58\u7ed3\u679c\n    results = {}\n    results['test_case_1'] = out.clone()\n\n    # \u6d4b\u8bd5\u4e0d\u540c\u7684\u8f93\u5165\n    input_ids = torch.randint(\n        vob_start_id, vob_end_id, (sequence_length,), dtype=torch.int32, device='cuda'\n    )\n    embedding(input_ids, weight, vob_start_id, vob_end_id, out)\n    results['test_case_2'] = out.clone()\n\n    # \u6d4b\u8bd5\u4e0d\u540c\u7684\u8bcd\u6c47\u8868\u8303\u56f4\n    vob_start_id = 0\n    vob_end_id = 500\n    input_ids = torch.randint(\n        vob_start_id, vob_end_id, (sequence_length,), dtype=torch.int32, device='cuda'\n    )\n    embedding(input_ids, weight, vob_start_id, vob_end_id, out)\n    results['test_case_3'] = out.clone()\n\n    # \u6d4b\u8bd5\u4e0d\u540c\u7684\u5d4c\u5165\u7ef4\u5ea6\n    embedding_dim = 256\n    weight = torch.randn(\n        vocab_size, embedding_dim, dtype=torch.float32, device='cuda'\n    )\n    out = torch.zeros(\n        sequence_length, embedding_dim, dtype=torch.float32, device='cuda'\n    )\n    embedding(input_ids, weight, vob_start_id, vob_end_id, out)\n    results['test_case_4'] = out.clone()\n\n    return results\n\nresult_gold = test_embedding()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n\n@triton.jit\ndef embedding_kernel(\n    ids,\n    weight,\n    out,\n    stride_idsb,\n    stride_idss,\n    stride_idsn,\n    stride_wb,\n    stride_wn,\n    stride_wd,\n    stride_ob,\n    stride_os,\n    stride_od,\n    N: tl.constexpr,\n    BLOCK_N: tl.constexpr,\n    BLOCK_NN: tl.constexpr,\n    BLOCK_DMODEL: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_b = pid\n    pid_s = 0\n    offset_n = pid * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask = offset_n < N\n\n    offset_ids = pid_b * stride_idsb + pid_s * stride_idss\n    ids_ptr = ids + offset_ids + offset_n * stride_idsn\n    curr_ids = tl.load(ids_ptr, mask=mask).to(tl.int32)\n\n    offset_d = tl.arange(0, BLOCK_DMODEL)\n    for i in range(BLOCK_NN):\n        offset_n_i = offset_n + i * BLOCK_N\n        mask_i = offset_n_i < N\n\n        ids_i = tl.load(ids + offset_ids + offset_n_i * stride_idsn, mask=mask_i).to(tl.int32)\n        weight_ptr = weight + ids_i * stride_wn + offset_d[None, :] * stride_wd\n        out_ptr = out + pid_b * stride_ob + offset_n_i * stride_os + offset_d[None, :] * stride_od\n        tl.store(out_ptr, tl.load(weight_ptr), mask=mask_i[:, None])\n\n\ndef embedding(ids: torch.Tensor, weight: torch.Tensor) -> torch.Tensor:\n    assert ids.dim() == 2\n    B, S = ids.shape\n    D = weight.size(-1)\n    out = torch.empty((B, S, D), dtype=weight.dtype, device=weight.device)\n\n    BLOCK_N = 16\n    BLOCK_NN = 4\n    BLOCK_DMODEL = triton.next_power_of_2(D)\n\n    grid = lambda META: (triton.cdiv(B * S, META[\"BLOCK_N\"]),)\n    embedding_kernel[grid](\n        ids,\n        weight,\n        out,\n        ids.stride(0),\n        ids.stride(1),\n        1,\n        weight.stride(0),\n        weight.stride(1),\n        1,\n        out.stride(0),\n        out.stride(1),\n        out.stride(2),\n        B * S,\n        BLOCK_N=BLOCK_N,\n        BLOCK_NN=BLOCK_NN,\n        BLOCK_DMODEL=BLOCK_DMODEL,\n    )\n    return out\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n        The code defines a Triton-based kernel for matrix multiplication of INT4 quantized weights and provides Python functions to handle the quantization and dequantization processes. \n        The 'matmul_kernel' function is a Triton kernel using @triton.jit which performs matrix multiplication. It processes the input matrices in tiles defined by BLOCK_SIZE_M, BLOCK_SIZE_N, and BLOCK_SIZE_K, and uses a loop to iterate over the K dimension to accumulate results in fp32 precision, subsequently stored in the output buffer, potentially employing atomic add for SPLIT_K > 1.\n        The kernel is set up with a wide variety of configurations, allowing Triton's autotuning capabilities to select optimal parameters based on matrix dimensions M, N, and K. It utilizes quantized INT4 weights, reconstructing them using scales and zero points to compute matrix products accurately. \n        The Python function 'matmul_dequantize_int4_s2' serves as an interface to this kernel, preparing data and launching the computation on specified grid dimensions.\n        The function 'quantize_int4' converts a floating-point weight matrix into INT4 format, organizing the data by packing 8 INT4 values into one INT32 and calculating scaling factors and zero points for each group of elements. \n        The helper function 'unpack_int4' is intended for testing; it unpacks the INT4 matrix back into a floating-point format to verify the quantization process.\n    ", "label": null, "file": "int4_matmul.py", "test_code": "\n\n\ndef test_correct_int4_s2(M=32, K=4096, N=4096):\n    group_size = 128\n    a = torch.randn((M, K), device='cuda', dtype=torch.float16)\n    b = torch.randn((K, N), device='cuda', dtype=torch.float16)\n    int_b, b_scale, b_zero_point, _ = quantize_int4(b, group_size=group_size)\n    \n    # Test case\n    triton_output = matmul_dequantize_int4_s2(a, int_b, b_scale, b_zero_point, group_size)\n    \n    results = {\n        \"test_case_1\": triton_output\n    }\n    \n    return results\n\nresult_gold = test_correct_int4_s2()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64, 'SPLIT_K': 1}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64,  'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32, 'SPLIT_K': 1}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32, 'SPLIT_K': 1}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64,  'BLOCK_SIZE_K': 32, 'SPLIT_K': 1}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64,  'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32, 'SPLIT_K': 1}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32,  'BLOCK_SIZE_K': 64, 'SPLIT_K': 1}, num_stages=4, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n    reset_to_zero=['c_ptr']\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    scales_ptr, zeros_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    stride_scale_g, stride_scale_n,\n    stride_zero_g, stride_zero_n,\n    groupsize,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    SPLIT_K: tl.constexpr,\n    IS_EVEN_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_in_group = 8 * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * 8\n    group_size_m = min(num_pid_m - first_pid_m, 8)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n\n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + (offs_k[:, None] // 8) * stride_bk + offs_n[None, :] * stride_bn\n\n    scales_offs_m = offs_n\n    zeros_offs_m  = (offs_n // 8)\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n\n    for k_start in range(0, tl.cdiv(K, BLOCK_SIZE_K * SPLIT_K)):\n        k_idx = k_start * BLOCK_SIZE_K * SPLIT_K + offs_k\n        mask_k = k_idx < K if not IS_EVEN_K else None\n\n        a = tl.load(a_ptrs, mask=mask_k, other=0.0).to(tl.float32)\n\n        packed = tl.load(b_ptrs, mask=mask_k, other=0)\n        shift = (k_idx % 8) * 4\n        b_int4 = (packed >> shift)[:, None] & 0xF\n        b_int4 = b_int4.squeeze(-1)\n\n        group_id_k = tl.min(k_idx, axis=0) // groupsize\n        scale = tl.load(scales_ptr + group_id_k * stride_scale_g + scales_offs_m * stride_scale_n)\n        zero  = tl.load(zeros_ptr  + group_id_k * stride_zero_g  + zeros_offs_m  * stride_zero_n)\n        zero  = (zero >> ((offs_n % 8) * 4)) & 0xF\n        zero  = zero * scale\n\n        b = (b_int4.to(tl.float32) - zero[None, :]) * scale[None, :]\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += (BLOCK_SIZE_K // 8) * stride_bk\n\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    mask_c = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n\n    if SPLIT_K > 1:\n        tl.atomic_add(c_ptrs, accumulator, mask=mask_c)\n    else:\n        tl.store(c_ptrs, accumulator.to(c_ptr.dtype.element_ty), mask=mask_c)\n\n\ndef matmul_dequantize_int4_s2(x: torch.Tensor, qweight: torch.Tensor, scales: torch.Tensor,\n                              zeros: torch.Tensor, group_size: int = 128) -> torch.Tensor:\n    assert x.dtype in (torch.float16, torch.float32)\n    assert qweight.dtype == torch.int32\n    assert scales.dtype in (torch.float16, torch.float32)\n    assert zeros.dtype in (torch.float16, torch.float32)\n\n    M, K = x.shape\n    K_packed, N = qweight.shape\n    assert K_packed * 8 == K\n\n    output = torch.empty((M, N), dtype=x.dtype, device=x.device)\n\n    grid = lambda META: (\n        triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),\n    )\n\n    matmul_kernel[grid](\n        x, qweight, output,\n        scales, zeros,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        qweight.stride(0), qweight.stride(1),\n        output.stride(0), output.stride(1),\n        scales.stride(0) if scales.dim() > 1 else 0,\n        scales.stride(1) if scales.dim() > 1 else 1,\n        zeros.stride(0)  if zeros.dim() > 1 else 0,\n        zeros.stride(1)  if zeros.dim() > 1 else 1,\n        group_size,\n    )\n    return output\n\n\ndef quantize_int4(w: torch.Tensor, group_size: int = 128):\n    assert w.dtype in [torch.float16, torch.float32]\n    K, N = w.shape\n    assert K % group_size == 0, \"K must be divisible by groupsize\"\n\n    w_reshaped = w.view(-1, group_size, N)\n    wmin = w_reshaped.min(dim=1, keepdim=True)[0]\n    wmax = w_reshaped.max(dim=1, keepdim=True)[0]\n    scale = (wmax - wmin) / 15.0\n    zero = torch.round(-wmin / scale).clamp(0, 15)\n    q = torch.round(w_reshaped / scale + zero).clamp(0, 15).to(torch.uint8)\n    q = q.view(K, N)\n\n    packed = torch.zeros(K // 8, N, dtype=torch.int32, device=w.device)\n    for k in range(8):\n        packed |= (q[k::8, :].to(torch.int32) << (k * 4))\n    scale = scale.squeeze(1).to(torch.float16)\n    zero  = zero.squeeze(1).to(torch.int32)\n\n    return packed, scale, zero\n\n\ndef unpack_int4(packed: torch.Tensor, scale: torch.Tensor, zero: torch.Tensor, group_size: int = 128):\n    assert packed.dtype == torch.int32\n    K_packed, N = packed.shape\n    K = K_packed * 8\n\n    unpacked = torch.zeros(K, N, dtype=torch.float32, device=packed.device)\n    for k in range(8):\n        unpacked[k::8, :] = ((packed >> (k * 4)) & 0xF).float()\n\n    unpacked = unpacked.view(-1, group_size, N)\n    scale_exp = scale.view(-1, 1, N)\n    zero_exp  = zero.view(-1, 1, N)\n    unpacked = (unpacked - zero_exp.float()) * scale_exp\n    return unpacked.view(K, N).to(torch.float16)\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The `_fwd_kernel_flash_decode_stage2` Triton kernel is a parallel computation designed for processing sequences in a neural network context, specifically dealing with batches, heads, and sequence blocks. This kernel receives several inputs: `B_Seqlen`, `Mid_O`, `Mid_O_LogExpSum`, and `Out`, along with strides for indexing. `B_Seqlen` contains sequence lengths per batch, `Mid_O` contains intermediate outputs, `Mid_O_LogExpSum` holds log-exp sum values, and `Out` will store the final output. The kernel operates over a 2D grid defined by batch size and head count (`grid = (batch, head_num)`), with constants `BLOCK_SEQ` and `BLOCK_DMODEL` indicating sequence block size and dimension alignment respectively.\n\n            The kernel function operates as follows:\n            - Identifies the current batch and head using `tl.program_id`.\n            - Initializes accumulators: `sum_exp`, `max_logic`, and `acc` to accumulate exponential logic and values.\n            - Loads the current sequence length and calculates the number of sequence blocks (`block_n_size`).\n            - Iterates over each block, where:\n                - It loads values (`tv`) from `Mid_O` and logic sums (`tlogic`) from `Mid_O_LogExpSum`.\n                - Computes the maximum logic value across blocks and scales previous accumulations.\n                - Updates the accumulators by computing the exponential of adjusted logic values and scaling/accumulating.\n            - Stores the final normalized result into `Out`, scaling accumulated values by the sum of exponentials.\n\n            The `flash_decode_stage2` function sets up and invokes this kernel, determining dimensions and grid setup based on input tensor shapes. It ensures efficient computation by using Triton's parallel execution framework, specifying warp and stage numbers.\n            ", "label": null, "file": "flash_decode2_phi.py", "test_code": "\n\n\nimport torch\n\n# Define the test function\ndef test_flash_decode_stage2():\n    # Define the parameters for different test cases\n    batch_size = 2\n    head_num = 4\n    seq_block_num = 3\n    head_dim = 64\n    block_seq = 16\n\n    test_cases = {\n        \"test_case_1\": {\n            \"B_Seqlen\": torch.randint(1, seq_block_num * block_seq, (batch_size,), dtype=torch.int32, device='cuda'),\n            \"mid_out\": torch.randn((batch_size, head_num, seq_block_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"mid_out_logexpsum\": torch.randn((batch_size, head_num, seq_block_num), dtype=torch.float32, device='cuda'),\n            \"Out\": torch.zeros((batch_size, head_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"block_seq\": block_seq\n        },\n        \"test_case_2\": {\n            \"B_Seqlen\": torch.randint(1, seq_block_num * block_seq, (batch_size,), dtype=torch.int32, device='cuda'),\n            \"mid_out\": torch.randn((batch_size, head_num, seq_block_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"mid_out_logexpsum\": torch.randn((batch_size, head_num, seq_block_num), dtype=torch.float32, device='cuda'),\n            \"Out\": torch.zeros((batch_size, head_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"block_seq\": block_seq + 1  # Different block size\n        },\n        \"test_case_3\": {\n            \"B_Seqlen\": torch.randint(1, seq_block_num * block_seq, (batch_size,), dtype=torch.int32, device='cuda'),\n            \"mid_out\": torch.randn((batch_size, head_num, seq_block_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"mid_out_logexpsum\": torch.randn((batch_size, head_num, seq_block_num), dtype=torch.float32, device='cuda'),\n            \"Out\": torch.zeros((batch_size, head_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"block_seq\": block_seq // 2  # Different block size\n        },\n        \"test_case_4\": {\n            \"B_Seqlen\": torch.randint(1, seq_block_num * block_seq, (batch_size,), dtype=torch.int32, device='cuda'),\n            \"mid_out\": torch.randn((batch_size, head_num, seq_block_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"mid_out_logexpsum\": torch.randn((batch_size, head_num, seq_block_num), dtype=torch.float32, device='cuda'),\n            \"Out\": torch.zeros((batch_size, head_num, head_dim), dtype=torch.float32, device='cuda'),\n            \"block_seq\": block_seq * 2  # Different block size\n        }\n    }\n\n    # Execute the function for all test cases\n    results = {}\n    for key, test_case in test_cases.items():\n        flash_decode_stage2(test_case[\"mid_out\"], test_case[\"mid_out_logexpsum\"], test_case[\"B_Seqlen\"], test_case[\"Out\"], test_case[\"block_seq\"])\n        results[key] = test_case[\"Out\"]\n\n    return results\n\n# Run the test\nresult_gold = test_flash_decode_stage2()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n\n@triton.jit\ndef _fwd_kernel_flash_decode_stage2(\n    B_Seqlen,\n    Mid_O,\n    Mid_O_LogExpSum,\n    Out,\n    stride_mid_ob,\n    stride_mid_oh,\n    stride_mid_os,\n    stride_mid_od,\n    stride_mid_lseb,\n    stride_mid_lseh,\n    stride_mid_lses,\n    stride_ob,\n    stride_oh,\n    stride_od,\n    BLOCK_SEQ: tl.constexpr,\n    BLOCK_DMODEL: tl.constexpr,\n):\n    cur_batch = tl.program_id(0)\n    cur_head = tl.program_id(1)\n\n    cur_seq_len = tl.load(B_Seqlen + cur_batch)\n    block_n_size = (cur_seq_len + BLOCK_SEQ - 1) // BLOCK_SEQ\n\n    sum_exp = 0.0\n    max_logic = float(\"-inf\")\n\n    offs_d = tl.arange(0, BLOCK_DMODEL)\n    acc = tl.zeros([BLOCK_DMODEL], dtype=tl.float32)\n\n    for block_i in range(0, block_n_size):\n        tv = tl.load(\n            Mid_O\n            + cur_batch * stride_mid_ob\n            + cur_head * stride_mid_oh\n            + block_i * stride_mid_os\n            + offs_d * stride_mid_od\n        ).to(tl.float32)\n\n        tlogic = tl.load(\n            Mid_O_LogExpSum\n            + cur_batch * stride_mid_lseb\n            + cur_head * stride_mid_lseh\n            + block_i * stride_mid_lses\n        ).to(tl.float32)\n\n        old_max = max_logic\n        new_max = tl.maximum(max_logic, tlogic)\n        max_logic = new_max\n\n        sum_exp = sum_exp * tl.exp(old_max - new_max) + tl.exp(tlogic - new_max)\n        acc = acc * tl.exp(old_max - new_max) + tv * tl.exp(tlogic - new_max)\n\n    acc = acc / sum_exp\n\n    offs_out = (\n        cur_batch * stride_ob\n        + cur_head * stride_oh\n        + offs_d * stride_od\n    )\n    tl.store(Out + offs_out, acc.to(Out.dtype.element_ty))\n\n\n@torch.no_grad()\ndef flash_decode_stage2(\n    Mid_O: torch.Tensor,\n    Mid_O_LogExpSum: torch.Tensor,\n    B_Seqlen: torch.Tensor,\n    Out: torch.Tensor,\n    block_seq: int,\n):\n    batch, head_num = Mid_O.shape[0], Mid_O.shape[1]\n    dim = Mid_O.shape[-1]\n\n    assert Mid_O_LogExpSum.shape[0] == batch and Mid_O_LogExpSum.shape[1] == head_num\n    assert Out.shape[0] == batch and Out.shape[1] == head_num and Out.shape[2] == dim\n\n    BLOCK_SEQ = block_seq\n    BLOCK_DMODEL = dim\n\n    grid = (batch, head_num)\n\n    _fwd_kernel_flash_decode_stage2[grid](\n        B_Seqlen,\n        Mid_O,\n        Mid_O_LogExpSum,\n        Out,\n        Mid_O.stride(0),\n        Mid_O.stride(1),\n        Mid_O.stride(2),\n        Mid_O.stride(3),\n        Mid_O_LogExpSum.stride(0),\n        Mid_O_LogExpSum.stride(1),\n        Mid_O_LogExpSum.stride(2),\n        Out.stride(0),\n        Out.stride(1),\n        Out.stride(2),\n        BLOCK_SEQ=BLOCK_SEQ,\n        BLOCK_DMODEL=BLOCK_DMODEL,\n        num_warps=4,\n        num_stages=1,\n    )\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\nThe Triton operator is defined to transpose a matrix using a kernel function and a wrapper function. The kernel function named 'kernel' is decorated with '@triton.jit' for just-in-time compilation and performs matrix transposition by directly manipulating pointers based on the given strides and dimensions. It accepts input parameters such as a matrix 'M', an output buffer 'Out', the strides of 'M' and 'Out', and the dimensions 'SIZE_M' and 'D_HEAD'. The kernel computes the pointers for elements of 'M' using 'matrix_stridex' and 'matrix_stridey', and for 'Out' using 'out_stridex' and 'out_stridey'. The transposition is achieved by loading elements from 'M' and storing them into 'Out' in a transposed layout. The wrapper function named 'wrapper' initializes 'matrix' with random float16 values and 'out' with zeros, both on CUDA. It defines the grid configuration as a tuple with a single element, then calls the kernel with these matrices and their properties. Finally, it returns the transposed matrix 'out'.\n    ", "label": null, "file": "matrix_transpose.py", "test_code": "\n\n\nimport torch\n\ndef test_triton_vs_torch():\n    results = {}\n\n    # \u6d4b\u8bd5\u7528\u4f8b 1: \u57fa\u672c\u77e9\u9635\u8f6c\u7f6e (\u5c0f\u77e9\u9635)\n    size_m, d_head = 16, 16\n    out = wrapper(size_m, d_head)\n    results[\"test_case_1\"] = out.clone()\n\n    # \u6d4b\u8bd5\u7528\u4f8b 2: \u975e\u65b9\u5f62\u77e9\u9635\n    size_m, d_head = 32, 64\n    out = wrapper(size_m, d_head)\n    results[\"test_case_2\"] = out.clone()\n\n    return results\n\n\n# \u8fd0\u884c\u6d4b\u8bd5\nresult_gold = test_triton_vs_torch()\n# print(result_gold)", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef kernel(\n    M,\n    Out,\n    matrix_stridex,\n    matrix_stridey,\n    out_stridex,\n    out_stridey,\n    SIZE_M,\n    D_HEAD,\n    BLOCK_M: tl.constexpr,\n    BLOCK_N: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n\n    mask_read = (offs_m[:, None] < SIZE_M) & (offs_n[None, :] < D_HEAD)\n    m_ptrs = M + offs_m[:, None] * matrix_stridex + offs_n[None, :] * matrix_stridey\n    x = tl.load(m_ptrs, mask=mask_read, other=0.0)\n\n    mask_write = (offs_n[:, None] < D_HEAD) & (offs_m[None, :] < SIZE_M)\n    o_ptrs = Out + offs_n[:, None] * out_stridex + offs_m[None, :] * out_stridey\n    tl.store(o_ptrs, x.trans(), mask=mask_write)\n\ndef wrapper(\n    SIZE_M: int,\n    D_HEAD: int,\n) -> torch.Tensor:\n    matrix = torch.randn((SIZE_M, D_HEAD), dtype=torch.float16, device='cuda')\n    out = torch.zeros((D_HEAD, SIZE_M), dtype=torch.float16, device='cuda')\n\n    BLOCK_M = 32\n    BLOCK_N = 32\n    grid = ((SIZE_M + BLOCK_M - 1) // BLOCK_M, (D_HEAD + BLOCK_N - 1) // BLOCK_N)\n\n    kernel[grid](\n        matrix, out,\n        matrix.stride(0),\n        matrix.stride(1),\n        out.stride(0),\n        out.stride(1),\n        SIZE_M,\n        D_HEAD,\n        BLOCK_M=BLOCK_M,\n        BLOCK_N=BLOCK_N,\n    )\n\n    return out\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n        The `rotary_kernel` function is a Triton kernel that performs rotary position encoding on a tensor `X` using precomputed cosine (`COS`) and sine (`SIN`) matrices. It modifies or populates the output tensor `OUT` with the transformed data. The kernel accommodates both fixed and variable sequence lengths, controlled by the presence of `CU_SEQLENS`. The kernel handles interleaved and non-interleaved formats and allows for in-place transformations and conjugate computations if specified.\n\n        The kernel operates in a three-dimensional grid, processing batches (`pid_batch`), heads (`pid_head`), and sequences (`pid_m`). It calculates transformations by loading blocks of data and applying rotary transformations based on cosine and sine values. The key operations are tailored based on whether the data is interleaved or not, with conditional handling for conjugation using `CONJUGATE`.\n\n        The `apply_rotary` function acts as a high-level interface to the Triton kernel. It accepts the input tensor `x`, cosine and sine matrices, sequence length offsets, and optional cumulative sequence lengths (`cu_seqlens`). The function determines the execution grid and block sizes, aligning them with the input data shape and configuration. It initializes an output tensor, copying non-rotary parts of `x` if required. The function ensures that the kernel is called with appropriate arguments, matching the shape and type expectations set within the kernel logic. This design allows for efficient rotary transformations in transformer architectures.\n    ", "label": null, "file": "rotary_transform.py", "test_code": "\n\n\nimport torch\n\ndef test_apply_rotary():\n    results = {}\n    \n    # Test case 1: Basic test with fixed sequence length and no interleaving\n    batch, seqlen, nheads, headdim = 2, 128, 4, 64\n    rotary_dim = 32\n    x = torch.randn(batch, seqlen, nheads, headdim, device='cuda')\n    cos = torch.randn(seqlen, rotary_dim // 2, device='cuda')\n    sin = torch.randn(seqlen, rotary_dim // 2, device='cuda')\n    output = apply_rotary(x, cos, sin)\n    results['test_case_1'] = output.shape\n\n    # Test case 2: Variable length sequences with interleaving\n    total_seqlen, nheads, headdim = 256, 4, 64\n    batch = 3\n    cu_seqlens = torch.tensor([0, 100, 200, 256], device='cuda')\n    max_seqlen = 128\n    rotary_dim = 32\n    x = torch.randn(total_seqlen, nheads, headdim, device='cuda')\n    cos = torch.randn(max_seqlen, rotary_dim // 2, device='cuda')\n    sin = torch.randn(max_seqlen, rotary_dim // 2, device='cuda')\n    output = apply_rotary(x, cos, sin, cu_seqlens=cu_seqlens, max_seqlen=max_seqlen, interleaved=True)\n    results['test_case_2'] = output.shape\n\n    # Test case 3: Conjugate flag enabled\n    batch, seqlen, nheads, headdim = 2, 128, 4, 64\n    rotary_dim = 32\n    x = torch.randn(batch, seqlen, nheads, headdim, device='cuda')\n    cos = torch.randn(seqlen, rotary_dim // 2, device='cuda')\n    sin = torch.randn(seqlen, rotary_dim // 2, device='cuda')\n    output = apply_rotary(x, cos, sin, conjugate=True)\n    results['test_case_3'] = output.shape\n\n    # Test case 4: Inplace operation\n    batch, seqlen, nheads, headdim = 2, 128, 4, 64\n    rotary_dim = 32\n    x = torch.randn(batch, seqlen, nheads, headdim, device='cuda')\n    cos = torch.randn(seqlen, rotary_dim // 2, device='cuda')\n    sin = torch.randn(seqlen, rotary_dim // 2, device='cuda')\n    output = apply_rotary(x, cos, sin, inplace=True)\n    results['test_case_4'] = output.shape\n\n    return results\n\nresult_gold = test_apply_rotary()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\nfrom typing import Union, Optional\n\n\n@triton.jit\ndef rotary_kernel(\n    OUT,\n    X,\n    COS,\n    SIN,\n    CU_SEQLENS,\n    SEQLEN_OFFSETS,\n    seqlen,\n    nheads,\n    rotary_dim,\n    seqlen_ro,\n    CACHE_KEY_SEQLEN,\n    stride_out_batch,\n    stride_out_seqlen,\n    stride_out_nheads,\n    stride_out_headdim,\n    stride_x_batch,\n    stride_x_seqlen,\n    stride_x_nheads,\n    stride_x_headdim,\n    BLOCK_K: tl.constexpr,\n    IS_SEQLEN_OFFSETS_TENSOR: tl.constexpr,\n    IS_VARLEN: tl.constexpr,\n    INTERLEAVED: tl.constexpr,\n    CONJUGATE: tl.constexpr,\n    BLOCK_M: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_batch = tl.program_id(1)\n    pid_head = tl.program_id(2)\n    rotary_dim_half = rotary_dim // 2\n\n    if not IS_VARLEN:\n        X = X + pid_batch * stride_x_batch + pid_head * stride_x_nheads\n        OUT = OUT + pid_batch * stride_out_batch + pid_head * stride_out_nheads\n    else:\n        start_idx = tl.load(CU_SEQLENS + pid_batch)\n        cur_seqlen = tl.load(CU_SEQLENS + pid_batch + 1) - start_idx\n        X = X + start_idx * stride_x_seqlen + pid_head * stride_x_nheads\n        OUT = OUT + start_idx * stride_out_seqlen + pid_head * stride_out_nheads\n    else_seqlen = seqlen if not IS_VARLEN else cur_seqlen\n\n    if pid_m * BLOCK_M >= else_seqlen:\n        return\n    rm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    if not IS_SEQLEN_OFFSETS_TENSOR:\n        rm_cs = rm + SEQLEN_OFFSETS\n    else:\n        rm_cs = rm + tl.load(SEQLEN_OFFSETS + pid_batch)\n    rm_cs = tl.where(rm < else_seqlen, rm_cs, 0)\n\n    if not INTERLEAVED:\n        rk_half = tl.arange(0, BLOCK_K // 2)\n        mask_half = (rm[:, None] < else_seqlen) & (rk_half[None, :] < rotary_dim_half)\n        cos_mask = (rm_cs[:, None] < seqlen_ro) & (rk_half[None, :] < rotary_dim_half)\n\n        cos = tl.load(\n            COS + rm_cs[:, None] * rotary_dim_half + rk_half[None, :],\n            mask=cos_mask,\n            other=1.0,\n        ).to(tl.float32)\n        sin = tl.load(\n            SIN + rm_cs[:, None] * rotary_dim_half + rk_half[None, :],\n            mask=cos_mask,\n            other=0.0,\n        ).to(tl.float32)\n        x0 = tl.load(\n            X + rm[:, None] * stride_x_seqlen + rk_half[None, :] * stride_x_headdim,\n            mask=mask_half,\n            other=0.0,\n        ).to(tl.float32)\n        x1 = tl.load(\n            X + rm[:, None] * stride_x_seqlen + (rk_half[None, :] + rotary_dim_half) * stride_x_headdim,\n            mask=mask_half,\n            other=0.0,\n        ).to(tl.float32)\n        if CONJUGATE:\n            sin = -sin\n        o0 = x0 * cos - x1 * sin\n        o1 = x0 * sin + x1 * cos\n        tl.store(\n            OUT + rm[:, None] * stride_out_seqlen + rk_half[None, :] * stride_out_headdim,\n            o0,\n            mask=mask_half,\n        )\n        tl.store(\n            OUT + rm[:, None] * stride_out_seqlen + (rk_half[None, :] + rotary_dim_half) * stride_out_headdim,\n            o1,\n            mask=mask_half,\n        )\n    else:\n        rk = tl.arange(0, BLOCK_K)\n        mask = (rm[:, None] < else_seqlen) & (rk[None, :] < rotary_dim)\n        rk_half = rk // 2\n        cos_mask = (rm_cs[:, None] < seqlen_ro) & (rk_half[None, :] < rotary_dim_half)\n\n        cos = tl.load(\n            COS + rm_cs[:, None] * rotary_dim_half + rk_half[None, :],\n            mask=cos_mask,\n            other=1.0,\n        ).to(tl.float32)\n        sin = tl.load(\n            SIN + rm_cs[:, None] * rotary_dim_half + rk_half[None, :],\n            mask=cos_mask,\n            other=0.0,\n        ).to(tl.float32)\n        x0 = tl.load(\n            X + rm[:, None] * stride_x_seqlen + rk[None, :] * stride_x_headdim,\n            mask=mask,\n            other=0.0,\n        ).to(tl.float32)\n        x1 = tl.load(\n            X + rm[:, None] * stride_x_seqlen + (rk[None, :] ^ 1) * stride_x_headdim,\n            mask=mask,\n            other=0.0,\n        ).to(tl.float32)\n        if CONJUGATE:\n            sin = -sin\n        x0_cos = x0 * cos\n        x1_sin = x1 * sin\n        out = tl.where(\n            rk[None, :] % 2 == 0,\n            x0_cos - x1_sin,\n            x0_cos + x1_sin,\n        )\n        tl.store(\n            OUT + rm[:, None] * stride_out_seqlen + rk[None, :] * stride_out_headdim,\n            out,\n            mask=mask,\n        )\n\n\ndef apply_rotary(\n    x: torch.Tensor,\n    cos: torch.Tensor,\n    sin: torch.Tensor,\n    seqlen_offsets: Union[int, torch.Tensor] = 0,\n    cu_seqlens: Optional[torch.Tensor] = None,\n    max_seqlen: Optional[int] = None,\n    interleaved: bool = False,\n    inplace: bool = False,\n    conjugate: bool = False,\n) -> torch.Tensor:\n    is_varlen = cu_seqlens is not None\n    if not is_varlen:\n        if x.ndim == 3:\n            x = x.unsqueeze(1)\n        batch, seqlen, nheads, headdim = x.shape\n    else:\n        assert max_seqlen is not None, \"If cu_seqlens is passed in, then max_seqlen must be passed\"\n        if x.ndim == 2:\n            x = x.unsqueeze(1)\n        total_seqlen, nheads, headdim = x.shape\n        batch_p_1 = cu_seqlens.shape[0]\n        batch = batch_p_1 - 1\n        seqlen = max_seqlen\n    seqlen_ro, rotary_dim_half = cos.shape\n    rotary_dim = rotary_dim_half * 2\n    assert sin.shape == cos.shape\n    assert rotary_dim <= headdim, \"rotary_dim must be <= headdim\"\n    assert headdim <= 256, \"Only support headdim <= 256\"\n    assert seqlen_ro >= seqlen, \"seqlen_ro must be >= seqlen\"\n\n    assert cos.dtype == sin.dtype, f\"cos and sin must have the same dtype, got {cos.dtype} and {sin.dtype}\"\n    assert x.dtype == cos.dtype, f\"Input and cos/sin must have the same dtype, got {x.dtype} and {cos.dtype}\"\n\n    cos, sin = cos.contiguous(), sin.contiguous()\n    if isinstance(seqlen_offsets, torch.Tensor):\n        assert seqlen_offsets.numel() == batch\n        assert seqlen_offsets.dtype in [torch.int32, torch.int64]\n        seqlen_offsets = seqlen_offsets.contiguous()\n    else:\n        assert isinstance(seqlen_offsets, int)\n        assert seqlen_offsets + seqlen <= seqlen_ro\n\n    output = torch.empty_like(x) if not inplace else x\n    if rotary_dim < headdim and not inplace:\n        output[..., rotary_dim:].copy_(x[..., rotary_dim:])\n\n    BLOCK_K = 32 if rotary_dim <= 32 else (64 if rotary_dim <= 64 else (128 if rotary_dim <= 128 else 256))\n    BLOCK_M = 4 if interleaved else (8 if rotary_dim <= 64 else 4)\n\n    grid = lambda META: (\n        triton.cdiv(seqlen, META[\"BLOCK_M\"]),\n        batch,\n        nheads,\n    )\n\n    rotary_kernel[grid](\n        output,\n        x,\n        cos,\n        sin,\n        cu_seqlens,\n        seqlen_offsets,\n        seqlen,\n        nheads,\n        rotary_dim,\n        seqlen_ro,\n        seqlen // 128,\n        output.stride(0) if not is_varlen else 1,\n        output.stride(-2) if is_varlen else output.stride(-3),\n        output.stride(-2),\n        output.stride(-1),\n        x.stride(0) if not is_varlen else 1,\n        x.stride(-2) if is_varlen else x.stride(-3),\n        x.stride(-2),\n        x.stride(-1),\n        BLOCK_K,\n        isinstance(seqlen_offsets, torch.Tensor),\n        is_varlen,\n        interleaved,\n        conjugate,\n        BLOCK_M,\n    )\n    return output\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The code implements a Triton kernel named `kernel_function`, which processes input data using block-wise operations. \n            The kernel takes pointers to input and output data (`x_ptr` and `output_ptr`), the total number of elements to process (`n_elements`), and a constant block size (`BLOCK_SIZE`). \n            Inside the kernel, each program instance calculates its starting point (`block_start`) and creates an `offsets` tensor for element indexing. \n            A mask ensures operations only occur on valid indices within the input bounds. The kernel loads data from `x_ptr`, computes the sine using `tl.math.sin`, and stores the result in `output_ptr`. \n            The `call_kernel` function prepares to execute the kernel by calculating the total number of elements (`n_elements`) and creates an output tensor. \n            It defines a grid configuration function using lambda to handle thread block calculations based on `BLOCK_SIZE`, ensuring the entire input is processed. \n            The kernel is then launched with the grid configuration, input, output, and element count.\n            ", "label": null, "file": "sin_kernel.py", "test_code": "\n\n\nimport torch\n\n# Function to test the Triton kernel\ndef test_call_kernel():\n    results = {}\n    \n    # Test case 1: Small input tensor\n    x1 = torch.tensor([0.0, 1.0, 2.0, 3.0], dtype=torch.float32).cuda()\n    output1 = call_kernel(x1)\n    results['test_case_1'] = output1\n    \n    # Test case 2: Larger input tensor\n    x2 = torch.linspace(0, 10, steps=1024, dtype=torch.float32).cuda()\n    output2 = call_kernel(x2)\n    results['test_case_2'] = output2\n\n    # Test case 3: Edge case with zero elements\n    x3 = torch.tensor([], dtype=torch.float32).cuda()\n    output3 = call_kernel(x3)\n    results['test_case_3'] = output3\n\n    # Test case 4: Input tensor with negative values\n    x4 = torch.tensor([-1.0, -2.0, -3.0, -4.0], dtype=torch.float32).cuda()\n    output4 = call_kernel(x4)\n    results['test_case_4'] = output4\n    \n    return results\n\n# Run the test function\nresult_gold = test_call_kernel()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n\n@triton.jit\ndef kernel_function(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    y = tl.math.sin(x.to(tl.float32))\n    tl.store(output_ptr + offsets, y, mask=mask)\n\n\ndef call_kernel(x: torch.Tensor, output: torch.Tensor = None, BLOCK_SIZE: int = 128):\n    assert x.is_cuda, \"Input tensor must reside on CUDA (ROCm) device\"\n    assert x.is_contiguous(), \"Input tensor must be contiguous\"\n    assert (BLOCK_SIZE & (BLOCK_SIZE - 1)) == 0, \"BLOCK_SIZE must be a power of two\"\n    n_elements = x.numel()\n    if n_elements == 0:\n        if output is None:\n            output = torch.empty_like(x)\n        return output\n\n    x = x.view(-1)\n    if output is None:\n        output = torch.empty_like(x)\n    else:\n        output = output.reshape(-1)\n        assert output.numel() >= n_elements\n    output = output.to(x.device)\n\n    grid = lambda meta: (triton.cdiv(n_elements, meta[\"BLOCK_SIZE\"]),)\n    kernel_function[grid](\n        x_ptr=x,\n        output_ptr=output,\n        n_elements=n_elements,\n        BLOCK_SIZE=BLOCK_SIZE,\n    )\n    return output\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n    The Triton kernel `_l2_norm_bwd_kernel` performs a backward pass operation for L2 normalization on a per-row basis. It receives pointers to input `X`, output gradient `DY`, and calculates the input gradient `DX`. Each row of the input is accessed using the `stride_x_row`. `BLOCK_N` determines the number of elements processed per block, set based on maximum allowable fused size and next power of 2 of `N`. Within the kernel, it computes the variance of the input slice, uses it to compute the reciprocal of the standard deviation (`rstd`), and then calculates `dx` using the formula `dy * rstd - tl.sum(dy * x) * (1 / (var+eps)) * rstd * x`. The result is conditionally stored in `DX` using masks. The `_l2_norm_bwd` function orchestrates this process, ensuring input tensors `x` and `dy` are properly reshaped and their strides configured for contiguity if necessary. If `N` exceeds `BLOCK_N`, an error is raised to prevent excessive feature dimensions. Finally, the kernel is launched over `M` rows of the reshaped tensors, and the output `dx` is reshaped back to the original input shape.\n    ", "label": null, "file": "l2_norm_bwd.py", "test_code": "\n\n\nimport torch\n\n# Test the backward L2 normalization\ndef test_l2_norm_bwd():\n    results = {}\n    \n    # Test case 1: Default case\n    x = torch.randn(4, 8, device='cuda', dtype=torch.float32)\n    dy = torch.randn(4, 8, device='cuda', dtype=torch.float32)\n    dx = _l2_norm_bwd(x, dy)\n    results['test_case_1'] = dx\n\n    # Test case 2: Different shape\n    x = torch.randn(2, 16, device='cuda', dtype=torch.float32)\n    dy = torch.randn(2, 16, device='cuda', dtype=torch.float32)\n    dx = _l2_norm_bwd(x, dy)\n    results['test_case_2'] = dx\n\n    # Test case 3: Larger tensor\n    x = torch.randn(8, 8, device='cuda', dtype=torch.float32)\n    dy = torch.randn(8, 8, device='cuda', dtype=torch.float32)\n    dx = _l2_norm_bwd(x, dy)\n    results['test_case_3'] = dx\n\n    # Test case 4: Edge case with small tensor\n    x = torch.randn(1, 8, device='cuda', dtype=torch.float32)\n    dy = torch.randn(1, 8, device='cuda', dtype=torch.float32)\n    dx = _l2_norm_bwd(x, dy)\n    results['test_case_4'] = dx\n\n    return results\n\n# Run the tests\nresult_gold = test_l2_norm_bwd()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n\n@triton.jit\ndef _l2_norm_bwd_kernel(\n    X,              # pointer to the input tensor\n    DY,             # pointer to the output gradient tensor\n    DX,             # pointer to the input gradient tensor\n    stride_x_row,   # stride between rows in X\n    N,              # number of columns (feature dim)\n    eps,            # small constant for numerical stability\n    BLOCK_N: tl.constexpr,\n):\n    row = tl.program_id(0)               # row index\n    cols = tl.arange(0, BLOCK_N)         # column indices\n    mask = cols < N                      # valid mask for this row\n\n    # Offset to row start\n    X_row = X + row * stride_x_row\n    DY_row = DY + row * stride_x_row\n    DX_row = DX + row * stride_x_row\n\n    # Load data\n    x = tl.load(X_row + cols, mask=mask, other=0.0).to(tl.float32)\n    dy = tl.load(DY_row + cols, mask=mask, other=0.0).to(tl.float32)\n\n    var = tl.sum(x * x, axis=0)\n    rstd = tl.math.rsqrt(var + eps)\n\n    # Compute gradient\n    dx = dy * rstd - tl.sum(dy * x, axis=0) * rstd / (var + eps) * x\n    tl.store(DX_row + cols, dx.to(DX.dtype.element_ty), mask=mask)\n\n\ndef _l2_norm_bwd(\n    x: torch.Tensor,\n    dy: torch.Tensor,\n    eps: float = 1e-5\n) -> torch.Tensor:\n    # Flatten and ensure contiguous\n    shape_og = x.shape\n    x = x.reshape(-1, x.size(-1)).contiguous()\n    dy = dy.reshape(-1, dy.size(-1)).contiguous()\n\n    M, N = x.shape\n    MAX_FUSED_SIZE = 65536 // x.element_size()\n    BLOCK_N = min(MAX_FUSED_SIZE, triton.next_power_of_2(N))\n    if N > BLOCK_N:\n        raise RuntimeError(\"Feature dimension too large for the fused kernel.\")\n\n    dx = torch.empty_like(x)\n\n    grid = (M,)\n    _l2_norm_bwd_kernel[grid](\n        x, dy, dx,\n        x.stride(0),\n        N,\n        eps,\n        BLOCK_N=BLOCK_N,\n    )\n\n    return dx.view(shape_og)\n"}, {"instruction": "You are a expert in writing Triton operators for efficient GPU programming. Use triton language write a kernel and wrapper according following instruction.\n            The Triton kernel `_l2_norm_fwd_1pass_kernel` aims to perform L2 normalization on a 2D input tensor `X`. It processes each row separately using Triton's parallel execution model. The kernel expects pointers to `X` and `Y` along with the stride for rows (`stride_x_row`), number of columns in `X` (`N`), a small constant `eps` to prevent division by zero, and a compile-time constant `BLOCK_N`. The kernel computes L2 normalization by first loading a block of data from `X`, calculating the sum of squares for variance, and computing the reciprocal of the square root of the variance plus `eps` to get `rstd`. It then multiplies the input block by `rstd` to produce the normalized values, which are stored in `Y`.\n\n            The Python function `_l2_norm_fwd` handles the setup and execution of the kernel. It first reshapes and possibly makes the input tensor `x` contiguous. It initializes an empty tensor `y` to store the output. The function calculates `BLOCK_N` based on `x`'s element size and ensures it doesn't exceed 64KB. If the feature dimension `N` is larger than `BLOCK_N`, it raises an error. The kernel is then launched with the total number of rows `M`, pointers to `x` and `y`, stride, number of columns, `eps`, and `BLOCK_N`. Finally, the function returns the normalized tensor reshaped to its original dimensions.\n            ", "label": null, "file": "l2_norm_triton1.py", "test_code": "\n\n\nimport torch\n\n# Test the forward L2 normalization\ndef test_l2_norm_fwd():\n    results = {}\n    \n    # Test case 1\n    x1 = torch.randn(4, 8, device='cuda', dtype=torch.float32)\n    y1 = _l2_norm_fwd(x1)\n    results['test_case_1'] = y1\n\n    # Test case 2: Different batch size\n    x2 = torch.randn(2, 8, device='cuda', dtype=torch.float32)\n    y2 = _l2_norm_fwd(x2)\n    results['test_case_2'] = y2\n\n    # Test case 3: Different feature size\n    x3 = torch.randn(4, 4, device='cuda', dtype=torch.float32)\n    y3 = _l2_norm_fwd(x3)\n    results['test_case_3'] = y3\n\n    # Test case 4: Larger tensor\n    x4 = torch.randn(8, 8, device='cuda', dtype=torch.float32)\n    y4 = _l2_norm_fwd(x4)\n    results['test_case_4'] = y4\n\n    return results\n\nresult_gold = test_l2_norm_fwd()\n", "predict": "\nimport torch\nimport triton\nimport triton.language as tl\n\n\n@triton.jit\ndef _l2_norm_fwd_1pass_kernel(\n    X,\n    Y,\n    stride_x_row,\n    stride_y_row,\n    N,\n    eps,\n    BLOCK_N: tl.constexpr,\n):\n    row = tl.program_id(0)\n    x_ptrs = X + row * stride_x_row\n    y_ptrs = Y + row * stride_y_row\n\n    acc = tl.zeros([], dtype=tl.float32)\n\n    for col_offset in tl.range(0, N, BLOCK_N):\n        cols = col_offset + tl.arange(0, BLOCK_N)\n        mask = cols < N\n        x = tl.load(x_ptrs + cols, mask=mask, other=0.0).to(tl.float32)\n        acc += tl.sum(x * x)\n\n    rstd = tl.math.rsqrt(acc + eps)\n\n    for col_offset in tl.range(0, N, BLOCK_N):\n        cols = col_offset + tl.arange(0, BLOCK_N)\n        mask = cols < N\n        x = tl.load(x_ptrs + cols, mask=mask, other=0.0).to(tl.float32)\n        x_norm = x * rstd\n        tl.store(y_ptrs + cols, x_norm, mask=mask)\n\n\ndef _l2_norm_fwd(\n    x: torch.Tensor,\n    eps: float = 1e-6,\n) -> torch.Tensor:\n    x_orig_shape = x.shape\n    x = x.view(-1, x.shape[-1]).contiguous()\n    M, N = x.shape\n    y = torch.empty_like(x)\n\n    element_size = x.element_size()\n    max_block_bytes = 65536\n    BLOCK_N = min(triton.next_power_of_2(N), max_block_bytes // element_size)\n    BLOCK_N = max(BLOCK_N, 16)\n\n    _l2_norm_fwd_1pass_kernel[(M,)](\n        x,\n        y,\n        x.stride(0),\n        y.stride(0),\n        N,\n        eps,\n        BLOCK_N=BLOCK_N,\n    )\n\n    return y.view(x_orig_shape)\n"}]